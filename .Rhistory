lty = 1)
# rescale the posterior so it is a true probability distrubution
# that sums to one.
true_post <- posterior/sum(posterior)
# Set some graphical parameters to tidy up the size of the margins
# and layout of the axes labels and axes ticks.
# mar = ... defines how many lines are in each of the plot margins
# mgp = ... determines which line the axes titles,
#           labels and lines are drawn
# tck = ... determines direction and length of axis tick marks
# lax = ... rotates the y-axis tick labels 90 degrees.
par(mar = c(5,5,2,1), mgp = c(4,1,0), tck = -.01, las = 1)
# plot the likelihood of the data, scaled by its sum which makes
# it a probability distribution.. Here i am scaling the
# y axis limit of the plot to be the max of the values
# we are plotting.
plot( (likelihood / sum(likelihood) ) ~ theta,
type = 'l',
ylab = 'Probability',
ylim = c(0, 1.1 * max(c(posterior/sum(posterior),
prior/sum(prior),
likelihood/sum(likelihood)))),
xlim = c(0, 7),
xlab = 'theta',
cex.axis = 1.2,
cex.lab = 1.2)
# add the prior distribution, similarly scaled, as a red line
lines( (prior / sum(prior)) ~ theta, col = 'red')
# add the posterior, similarly scaled, as a blue line
lines( (posterior / sum(posterior)) ~ theta, col = 'blue')
# add a figure legend
legend('topright',
legend = c('Likelihood','Prior','Posterior'),
col = c('black','red','blue'),
lty = 1)
# rescale the posterior so it is a true probability distrubution
# that sums to one.
true_post <- posterior/sum(posterior)
---
title: "First JAGS models"
output: html_notebook
editor_options:
chunk_output_type: inline
---
This short example follows on from this morning's example where we were exploring how the prior and likelihood combine to generate the posterior. We will now turn to using JAGS as a way to fit the same model. In doing so, it makes it straight forward to estimate multiple parameters simultaneously. We can also use this simple example to understand the process a bit more, and explore important points such as model convergence which becomes more important as the complexity of the models increases: anyone who has used MixSIAR will know this only too well... depending on what you are tyring to do, it is potentially a beast of a model.
## Recreate our simple model
Earlier, we fitted a very simple model where we estimated only the mean of our data, assuming we knew the standard deviation exactly. We can recreate this using JAGS, which is similar in appearance to R code, but it *is not* compatible with R, nor is it ever inpreted by R, and rather it is passed to the underlying JAGS software installed on your computer for evaluation.
The JAGS model is written as plain text, and it is either written to a `*.txt` file and passed to JAGS via the R package `rjags`, or you can write it out in-line in your R code as a string, and pass it as a text object using the function `textConnection()`. We will use the latter approach here as our models are relatively short and it is easier to view them in our R code.
A JAGS model consists of two key components: A section defining the Likelihood, and then a section that defines the Prior distribution for all the unknown parameters that we want to estimate. You dont have to explicitly label these as such, but it is helpful, and it doesnt matter which order you put them in the model code, but again it probably helps to define the likelihood first and the priors second. Beyond simple cases, it sometimes gets confusing as to what is part of the likelihood and what is part of the prior, but that comes with experience.
*__N.B.__* JAGS uses the precision ($\tau$) notation rather than standard deviation ($\sigma$) or variance ($ \sigma^2$) , so remember that:
$$\sigma^2 = \frac{1}{\tau}$$
and
$$\tau = \frac{1}{\sigma^2} = \sigma^{-2}$$
```{r simple-model}
library(rjags)
# we define our JAGS model as a string of text between two
# inverted commas (either single or double is fine)
modelstring <- '
model {
# Define the Likelihood of the data
# normally distributed with known standard deviation.
x ~ dnorm(theta, 0.8^-2)
# Define the Prior for all unknown parameters
theta ~ dnorm(2.3, 0.5^-2)
}
'
# Set up data which is passed in to the JAGS model
# as a list, with vectors and matrices the same name
# as appear in the JAGS model.
data <- list(x = 3.1)
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 1000)
# Plot output
plot(density(output[[1]]))
```
# we define our JAGS model as a string of text between two
# inverted commas (either single or double is fine)
modelstring <- '
model {
# Define the Likelihood of the data
# Define the Likelihood of the data
# normally distributed with known standard deviation.
# Define the Likelihood of the data
# normally distributed with known standard deviation.
x ~ dnorm(theta, 0.8^-2)
# Define the Prior for all unknown parameters
# Define the Prior for all unknown parameters
theta ~ dnorm(2.3, 0.5^-2)
}
'
# Set up data which is passed in to the JAGS model
# as a list, with vectors and matrices the same name
# as appear in the JAGS model.
data <- list(x = 3.1)
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 1000)
# Plot output
plot(density(output[[1]]))
plot(output)
?coda.samples
?jags.model
plot(output)
?jags.model
?coda.samples
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 1000)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
?jags.model
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(x = -10),
list(x =  10),
list(x = 100)))
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -10),
list(theta =  10),
list(theta = 100)))
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 1000)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
?jags.model
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -10),
list(theta =  10),
list(theta = 100)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 1000)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
?coda.samples
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -10),
list(theta =  10),
list(theta = 100)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 100)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -1000),
list(theta =  10),
list(theta = 10000)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 100)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -1000),
list(theta =  10),
list(theta = 10000)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 10)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output)
?plot.mcmc
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -1000),
list(theta =  10),
list(theta = 10000)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 10)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output, smooth = FALSE)
output[[1]]
output[[2]]
output[[3]]
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(theta = -1000),
theta =  10),
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(theta = -1000,
theta =  10,
theta = 10000)
n.adapt = 0)
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(theta = -1000,
theta =  10,
theta = 10000),
n.adapt = 0)
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3,
inits = list(list(theta = -1000),
list(theta =  10),
list(theta = 10000)),
n.adapt = 0)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 10)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output, smooth = FALSE)
# set up a new model with 3 chains
# The jags model is initialised using jags.model()
model <- jags.model(textConnection(modelstring), data = data,
n.chains = 3)
# We then use coda.samples to ask for posterior draws
# which we will use as a reflectin of the posterior.
output <- coda.samples(model = model,
variable.names = c("theta"),
n.iter = 10)
# Plot output
# Passing the entire object we called output to plot()
# will automatically create a set of trace and density plots
plot(output, smooth = FALSE)
library(coda)
??BGR
summary(output)
output
?coda
??gelman.diag
gelman.diag(output)
gelman.plot(output)
?gelman.plot(output)
modelstring ='
model {
# Likelihood
for(i in 1:n) {
x[i] ~ dnorm(theta,sd^-2)
}
# -------------------------------------------------------
# Priors on both theta and sd
# Note that for both, I am passing the parametrs of these
# prior distributions in as data, which makes it
# easier for us to change them in the R code.
theta ~ dnorm(prior.mu.theta, prior.sd.theta^-2)
sd ~ dunif(prior.sd.min, prior.sd.max)
}
'
# Set up data which includes the parameters governing the
# priors.
data <- list(x = c(3.1,2.7,4.2,3.6),
n = 4,
prior.mu.theta = 2.3,
prior.sd.theta = 0.5,
prior.sd.min = 0,
prior.sd.max = 100)
# Set up and run jags
model <- jags.model(textConnection(modelstring), data = data,
n.iter = 1000, n.chains = 3)
modelstring ='
model {
# Likelihood
for(i in 1:n) {
x[i] ~ dnorm(theta,sd^-2)
}
# -------------------------------------------------------
# Priors on both theta and sd
# Note that for both, I am passing the parametrs of these
# prior distributions in as data, which makes it
# easier for us to change them in the R code.
theta ~ dnorm(prior.mu.theta, prior.sd.theta^-2)
sd ~ dunif(prior.sd.min, prior.sd.max)
}
'
# Set up data which includes the parameters governing the
# priors.
data <- list(x = c(3.1,2.7,4.2,3.6),
n = 4,
prior.mu.theta = 2.3,
prior.sd.theta = 0.5,
prior.sd.min = 0,
prior.sd.max = 100)
# Set up and run jags
model <- jags.model(textConnection(modelstring),
data = data,
n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("theta","sd"),
n.iter = 1000)
plot(output)
gelman.plot(output)
gelman.diag(output)
plot(output, smooth = FALSE)
x <- c(18.07, 52.59, 54.93, 79.31, 89.58)
y <- c(7.89, 12.41, 13.34, 19.3, 19.52)
plot(y ~ x,
xlab = 'Percentage of food source in diet (x)',
ylab = 'Weight (y)',
las = 1)
abline(glm(y~x), col='red')
summary(output)
modelstring ='
model {
# Define the Likelihood
for(i in 1:N) {
y[i] ~ dnorm(alpha + beta*x[i], sigma^-2)
}
# -------------------------------------------
# Prior distributions on our three parameters
# Note: vague priors
alpha ~ dnorm(0, 100^-2)
beta  ~ dnorm(0, 100^-2)
sigma ~ dunif(0, 100)
}
'
# bundle the data into a list for passing to rjags
data <- list(x = x,
y = y,
N = 5)
# set up the model
model <- jags.model(textConnection(modelstring),
data= data,
n.chains = 3)
# evaluate the model
output <- coda.samples(model = model,
variable.names = c("alpha", "beta"),
n.iter = 10000)
summary(output)
?coda.samples
names(output[[1]])
head(output[[1]])
head(output[[1]][,"beta"])
p_beta_gt_zero <- sum(output[[1]][,"beta"] > 0) / length(output[[1]][,"beta"])
p_beta_gt_zero
# Load in the data
data(geese1demo); data(sourcesdemo)
# extract only the d13C data for the consumers
consumers <- geese1demo[,2]
# extract only the d13C data for grass and zostera
sources <- sourcesdemo[1:2,4:5]
# create a vector to represent the probability
# densities of the sources
con_grid <- seq(-35,-5,length=100)
# plot these densities
plot(con_grid, dnorm(con_grid,
mean = sources[2,1],
sd = sources[2,2]),
type = 'l', col = 'red',
xlab = 'd13C', ylab = 'Probability density')
# Add the consumers as a blue density curve
lines(con_grid, dnorm(con_grid,
mean = sources[1,1],
sd = sources[1,2]),
col='blue')
# add the consumer data as points on the x axis
points(consumers,rep(0,9))
# add a legend
legend('topright',legend=c('Grass','Zostera','Consumers'),
lty=c(1,1,-1),pch=c(-1,-1,1),col=c('red','blue','black'))
library(siar)
# Load in the data
data(geese1demo); data(sourcesdemo)
# extract only the d13C data for the consumers
consumers <- geese1demo[,2]
# extract only the d13C data for grass and zostera
sources <- sourcesdemo[1:2,4:5]
# create a vector to represent the probability
# densities of the sources
con_grid <- seq(-35,-5,length=100)
# plot these densities
plot(con_grid, dnorm(con_grid,
mean = sources[2,1],
sd = sources[2,2]),
type = 'l', col = 'red',
xlab = 'd13C', ylab = 'Probability density')
# Add the consumers as a blue density curve
lines(con_grid, dnorm(con_grid,
mean = sources[1,1],
sd = sources[1,2]),
col='blue')
# add the consumer data as points on the x axis
points(consumers,rep(0,9))
# add a legend
legend('topright',legend=c('Grass','Zostera','Consumers'),
lty=c(1,1,-1),pch=c(-1,-1,1),col=c('red','blue','black'))
# write out our JAGS model
modelstring ='
model {
# The likelihood
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( (p_1 * s_1) + (p_2 * s_2), sigma^-2)
}
# --------------------------------------
# --------------------------------------
# the priors
# p_1 is uniform distributed and p_2 = 1 - p_1
# p_1 is uniform distributed and p_2 = 1 - p_1
p_1 ~ dunif(0,1)
p_2 <- 1-p_1
# The sources are treated as priors, with means
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
# And finally we have our residual error term.
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1","p_2"),
n.iter = 10000)
gelman.diag(output)
plot(output)
summary(output)
?gelman.diag
gelman.diag(output, multivariate = FALSE)
data("correctionsdemo")
# plot the results
plot(output, smooth = FALSE)
setwd("~/Documents/Projects/ISOECOL-2018-workshop")
