ylim = c(0, 20) )
abline(glm(y~x), col='red')
x <- c(18.07, 52.59, 54.93, 79.31, 89.58)
y <- c(7.89, 12.41, 13.34, 19.3, 19.52)
plot(y ~ x,
xlab = 'Percentage of food source in diet (x)',
ylab = 'Weight (y)',
las = 1,
xlim = c(0,100),
ylim = c(0, max(y)*1.1) )
abline(glm(y~x), col='red')
x <- c(18.07, 52.59, 54.93, 79.31, 89.58)
y <- c(7.89, 12.41, 13.34, 19.3, 19.52)
plot(y ~ x,
xlab = 'Percentage of food source in diet (x)',
ylab = 'Weight (y)',
las = 1,
xlim = c(0,100),
ylim = c(0, max(y)*1.1),
bty = "L")
abline(glm(y~x), col='red')
summary(m1)
x <- c(18.07, 52.59, 54.93, 79.31, 89.58)
y <- c(7.89, 12.41, 13.34, 19.3, 19.52)
plot(y ~ x,
xlab = 'Percentage of food source in diet (x)',
ylab = 'Weight (y)',
las = 1,
xlim = c(0,100),
ylim = c(0, max(y)*1.1),
bty = "L")
m1 <- glm(y ~ x)
summary(m1)
abline(m1, col='red')
library(rjags)
modelstring ='
model {
# Define the Likelihood
for(i in 1:N) {
y[i] ~ dnorm(alpha + beta*x[i], sigma^-2)
}
# -------------------------------------------
# Prior distributions on our three parameters
# Note: vague priors
alpha ~ dnorm(0, 100^-2)
beta  ~ dnorm(0, 100^-2)
sigma ~ dunif(0, 100)
}
'
# bundle the data into a list for passing to rjags
data <- list(x = x,
y = y,
N = 5)
# set up the model
model <- jags.model(textConnection(modelstring),
data= data,
n.chains = 3)
# evaluate the model
output <- coda.samples(model = model,
variable.names = c("alpha", "beta"),
n.iter = 10000)
str(output)
str(output[[1]])
str(output[[1]])
head(output[[1]])
names(output[[1]])
# plot the correlation between alpha and beta
# for chain 1
plot(output[[1]][, "alpha"] ~ output[[1]][, "beta"])
# plot the correlation between alpha and beta
# for chain 1
plot(output[[1]][, "alpha"],output[[1]][, "beta"])
?plot
plot.default(output[[1]][, "alpha"],output[[1]][, "beta"])
# plot the correlation between alpha and beta
# for chain 1
plot.default(output[[1]][, "alpha"],
output[[1]][, "beta"],
cex = 0.7,
color = "grey")
# plot the correlation between alpha and beta
# for chain 1
plot.default(output[[1]][, "alpha"],
output[[1]][, "beta"],
cex = 0.7,
col= "grey")
# plot the correlation between alpha and beta
# for chain 1
plot.default(output[[1]][, "alpha"],
output[[1]][, "beta"],
cex = 0.7,
col= 1)
# plot the correlation between alpha and beta
# for chain 1
plot.default(output[[1]][, "alpha"],
output[[1]][, "beta"],
cex = 0.7,
col= 1,
pch = 21)
# plot the correlation between alpha and beta
# for chain 1
plot.default(output[[1]][, "alpha"],
output[[1]][, "beta"],
cex = 0.7,
col= 1,
pch = 19)
cor.test(output[[1]][, "alpha"],
output[[1]][, "beta"])
summary(m1)
library(rjags)
modelstring ='
model {
# Define the Likelihood
for(i in 1:N) {
y[i] ~ dnorm(alpha + beta*x[i], sigma^-2)
}
# -------------------------------------------
# Prior distributions on our three parameters
# Note: vague priors
alpha ~ dnorm(0, 100^-2)
beta  ~ dnorm(0, 100^-2)
sigma ~ dunif(0, 100)
}
'
# bundle the data into a list for passing to rjags
data <- list(x = x,
y = y,
N = 5)
# set up the model
model <- jags.model(textConnection(modelstring),
data= data,
n.chains = 3)
# evaluate the model
output <- coda.samples(model = model,
variable.names = c("alpha",
"beta",
"sigma"),
n.iter = 10000)
summary(output)
1.5306 ^ 2
# Load in the data
data(geese1demo); data(sourcesdemo)
library(siar)
# Load in the data
data(geese1demo); data(sourcesdemo)
geese1demo
sourcesdemo
sourcesdemo
# extract only the d13C data for the consumers
consumers <- geese1demo[,2]
consumers
# extract only the d13C data for grass and zostera
sources <- sourcesdemo[1:2,4:5]
sources
# create a vector to represent the probability
# densities of the sources
con_grid <- seq(-35,-5,length=100)
# plot these densities for Grass in green
plot(con_grid, dnorm(con_grid,
mean = sources[2,1],
sd = sources[2,2]),
type = 'l', col = 'red',
xlab = 'd13C', ylab = 'Probability density')
# Add Zostera to the plot in blue
lines(con_grid, dnorm(con_grid,
mean = sources[1,1],
sd = sources[1,2]),
col='blue')
# add the consumer data as points on the x axis
points(consumers,rep(0,9))
# add a legend
legend('topright',legend=c('Grass','Zostera','Consumers'),
lty=c(1,1,-1),pch=c(-1,-1,1),col=c('red','blue','black'))
# plot these densities for Grass in green
plot(con_grid, dnorm(con_grid,
mean = sources[2,1],
sd = sources[2,2]),
type = 'l', col = 'red',
xlab = 'd13C', ylab = 'Probability density')
# Add Zostera to the plot in blue
lines(con_grid, dnorm(con_grid,
mean = sources[1,1],
sd = sources[1,2]),
col='blue')
# add the consumer data as points on the x axis
points(consumers,rep(0,9))
# add a legend
legend('topright',legend=c('Grass','Zostera','Consumers'),
lty=c(1,1,-1),pch=c(-1,-1,1),col=c('red','blue','black'))
# load rjags
library(rjags)
# write out our JAGS model
modelstring ='
model {
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( (p_1 * s_1) + (p_2 * s_2), sigma^-2)
}
# --------------------------------------
# the priors
# p_1 is uniform distributed and p_2 = 1 - p_1
p_1 ~ dunif(0,1)
p_2 <- 1-p_1
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1","p_2"),
n.iter = 10000)
# NB because of the strict correlation between
# p_1 and p_2, the gelman statistic for convergence
# will fail if we use the default
# option multivariate = TRUE.
gelman.diag(output, multivariate = FALSE)
# plot the results
plot(output, smooth = FALSE)
# summary of the parameters
summary(output)
plot(output)
# Load in the data
data(geese1demo); data(sourcesdemo)
# extract only the d13C data for the consumers
consumers <- geese1demo[,2]
# extract only the d13C data for grass and zostera
sources <- sourcesdemo[1:3,4:5]
# load rjags
library(rjags)
# write out our JAGS model
modelstring ='
model {
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( (p_1 * s_1  + p_2 * s_2 + p_3 * s_3, sigma^-2)
}
# --------------------------------------
# the priors
pp ~ ddirch(1,1,1)
p_1 <- pp[1]
p_2 <- pp[2]
p_3 <- pp[3]
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
s_3 ~ dnorm(s_3_mean,s_3_sd^-2)
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
s_3_mean = sources[2,1],
s_3_sd   = sources[2,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1","p_2", "p_3"),
n.iter = 10000)
# NB because of the strict correlation between
# p_1 and p_2, the gelman statistic for convergence
# will fail if we use the default
# option multivariate = TRUE.
gelman.diag(output, multivariate = FALSE)
# plot the results
plot(output, smooth = FALSE)
# summary of the parameters
summary(output)
summary(output)
sources
# load rjags
library(rjags)
# write out our JAGS model
modelstring ='
model {
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( (p_1 * s_1  + p_2 * s_2 + p_3 * s_3, sigma^-2)
}
# --------------------------------------
# the priors
pp ~ ddirch(1,1,1)
p_1 <- pp[1]
p_2 <- pp[2]
p_3 <- pp[3]
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
s_3 ~ dnorm(s_3_mean,s_3_sd^-2)
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
s_3_mean = sources[3,1],
s_3_sd   = sources[3,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1","p_2", "p_3"),
n.iter = 10000)
# NB because of the strict correlation between
# p_1 and p_2, the gelman statistic for convergence
# will fail if we use the default
# option multivariate = TRUE.
gelman.diag(output, multivariate = FALSE)
# plot the results
plot(output, smooth = FALSE)
# summary of the parameters
summary(output)
head(output[[1]])
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
# load rjags
library(rjags)
# write out our JAGS model
modelstring ='
model {
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( p_1 * s_1  + p_2 * s_2 + p_3 * s_3, sigma^-2)
}
# --------------------------------------
# the priors
pp ~ ddirch(1,1,1)
p_1 <- pp[1]
p_2 <- pp[2]
p_3 <- pp[3]
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
s_3 ~ dnorm(s_3_mean,s_3_sd^-2)
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
s_3_mean = sources[3,1],
s_3_sd   = sources[3,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1",
"p_2",
"p_3"),
n.iter = 10000)
# NB because of the strict correlation between
# p_1 and p_2, the gelman statistic for convergence
# will fail if we use the default
# option multivariate = TRUE.
gelman.diag(output, multivariate = FALSE)
# plot the results
plot(output, smooth = FALSE)
# summary of the parameters
summary(output)
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
# load rjags
library(rjags)
# write out our JAGS model
modelstring ='
model {
# The likelihood
for(i in 1:N) {
y[i] ~ dnorm( p_1 * s_1  + p_2 * s_2 + p_3 * s_3, sigma^-2)
}
# --------------------------------------
# the priors
pp ~ ddirch(c(1,1,1))
p_1 <- pp[1]
p_2 <- pp[2]
p_3 <- pp[3]
# The sources are treated as priors, with means
# specified as data coming in to the model from the
# sources object above.
s_1 ~ dnorm(s_1_mean,s_1_sd^-2)
s_2 ~ dnorm(s_2_mean,s_2_sd^-2)
s_3 ~ dnorm(s_3_mean,s_3_sd^-2)
# And finally we have our residual error term.
sigma ~ dunif(0,10)
}
'
# bundle our data into a list
data <- list(y = consumers,
s_1_mean = sources[1,1],
s_1_sd   = sources[1,2],
s_2_mean = sources[2,1],
s_2_sd   = sources[2,2],
s_3_mean = sources[3,1],
s_3_sd   = sources[3,2],
N = length(consumers))
# set up the jags model
model <- jags.model(textConnection(modelstring),
data = data, n.chains = 3)
output <- coda.samples(model = model,
variable.names = c("p_1",
"p_2",
"p_3"),
n.iter = 10000)
# NB because of the strict correlation between
# p_1 and p_2, the gelman statistic for convergence
# will fail if we use the default
# option multivariate = TRUE.
gelman.diag(output, multivariate = FALSE)
# plot the results
plot(output, smooth = FALSE)
# summary of the parameters
summary(output)
sources
sourcesdemo
pairs(output[[1]])
plot.default(output[[1]][,1], output[[1]][,2])
plot.default(output[[1]][,1], output[[1]][,3])
plot.default(output[[1]][,2], output[[1]][,3])
diag(2)
library(SIBER)
plot.default(output[[1]][,2], output[[1]][,3] + output[[1]][,1])
library(simmr)
?simmr
# The data
mix = matrix(c(-10.13, -10.72, -11.39, -11.18, -10.81, -10.7, -10.54,
-10.48, -9.93, -9.37, 11.59, 11.01, 10.59, 10.97, 11.52, 11.89,
11.73, 10.89, 11.05, 12.3), ncol=2, nrow=10)
colnames(mix) = c('d13C','d15N')
s_names=c('Source A','Source B','Source C','Source D')
s_means = matrix(c(-14, -15.1, -11.03, -14.44, 3.06, 7.05, 13.72, 5.96), ncol=2, nrow=4)
s_sds = matrix(c(0.48, 0.38, 0.48, 0.43, 0.46, 0.39, 0.42, 0.48), ncol=2, nrow=4)
c_means = matrix(c(2.63, 1.59, 3.41, 3.04, 3.28, 2.34, 2.14, 2.36), ncol=2, nrow=4)
c_sds = matrix(c(0.41, 0.44, 0.34, 0.46, 0.46, 0.48, 0.46, 0.66), ncol=2, nrow=4)
conc = matrix(c(0.02, 0.1, 0.12, 0.04, 0.02, 0.1, 0.09, 0.05), ncol=2, nrow=4)
# Load into simmr
simmr_1 = simmr_load(mixtures=mix,
source_names=s_names,
source_means=s_means,
source_sds=s_sds,
correction_means=c_means,
correction_sds=c_sds,
concentration_means = conc)
# Plot
plot(simmr_1)
# MCMC run
simmr_1_out = simmr_mcmc(simmr_1)
# Print it
print(simmr_1_out)
plot(simmr_1_out,type='boxplot')
simmr_out_combine = combine_sources(simmr_1_out,
to_combine=c('U.lactuca','Enteromorpha'),
new_source_name='U.lac+Ent')
plot(simmr_out_combine$input)
plot(simmr_out_combine,type='boxplot',title='simmr output: combined sources')
to_combine=c('A','D'),
new_source_name='AD')
simmr_out_combine = combine_sources(simmr_1_out,
to_combine=c('A','D'),
new_source_name='AD')
plot(simmr_out_combine$input)
plot(simmr_out_combine,type='boxplot',title='simmr output: combined sources')
simmr_out_combine = combine_sources(simmr_1_out,
to_combine=c('Source A','Source D'),
new_source_name='AD')
plot(simmr_out_combine$input)
plot(simmr_out_combine,type='boxplot',title='simmr output: combined sources')
x <- rep(1,5)
y <- rep(2,5)
x
y
cov(x, 1)
cov(x, y)
cov(cbind(x, y))
?laymanMetrics
